#if 0
/*
Copyright (c) 2014, Trail of Bits
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

  Redistributions in binary form must reproduce the above copyright notice, this  list of conditions and the following disclaimer in the documentation and/or
  other materials provided with the distribution.

  Neither the name of Trail of Bits nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
// Generated by llvm2cpp with manual modifications

#include <llvm/Pass.h>
#include <llvm/PassManager.h>
#include <llvm/ADT/SmallVector.h>
#include <llvm/IR/Verifier.h>
#include <llvm/IR/BasicBlock.h>
#include <llvm/IR/CallingConv.h>
#include <llvm/IR/Constants.h>
#include <llvm/IR/DerivedTypes.h>
#include <llvm/IR/Function.h>
#include <llvm/IR/GlobalVariable.h>
#include <llvm/IR/InlineAsm.h>
#include <llvm/IR/Instructions.h>
#include <llvm/IR/Attributes.h>
#include <llvm/IR/LLVMContext.h>
#include <llvm/IR/Module.h>
#include <llvm/Support/FormattedStream.h>
#include <llvm/Support/MathExtras.h>
#include <llvm/IR/DataLayout.h>
#include <algorithm>

#include "raiseX86.h"
#include "X86.h"

using namespace llvm;

extern llvm::PointerType *g_PRegStruct;
extern llvm::StructType *g_RegStruct;


static CallingConv::ID getCallingConv(Module *M){
	if(getSystemArch(M) == _X86_){
		return CallingConv::X86_StdCall;
	} else {
		return CallingConv::X86_64_Win64;
	}
}

static PointerType* getTibPtrTy(Module *mod) {
	PointerType* Int8PtrTy = PointerType::get(IntegerType::get(mod->getContext(), 8), 0);
	StructType *StructTy_struct__NT_TIB = mod->getTypeByName("struct._NT_TIB");
	if (!StructTy_struct__NT_TIB) {
		StructTy_struct__NT_TIB = StructType::create(mod->getContext(), "struct._NT_TIB");
	}
	std::vector<Type*>StructTy_struct__NT_TIB_fields;
	StructType *StructTy_struct__EXCEPTION_REGISTRATION_RECORD = mod->getTypeByName("struct._EXCEPTION_REGISTRATION_RECORD");
	if (!StructTy_struct__EXCEPTION_REGISTRATION_RECORD) {
		StructTy_struct__EXCEPTION_REGISTRATION_RECORD = StructType::create(mod->getContext(), "struct._EXCEPTION_REGISTRATION_RECORD");
	}
	std::vector<Type*>StructTy_struct__EXCEPTION_REGISTRATION_RECORD_fields;
	if (StructTy_struct__EXCEPTION_REGISTRATION_RECORD->isOpaque()) {
		StructTy_struct__EXCEPTION_REGISTRATION_RECORD->setBody(StructTy_struct__EXCEPTION_REGISTRATION_RECORD_fields, /*isPacked=*/false);
	}

	PointerType* PointerTy_44 = PointerType::get(StructTy_struct__EXCEPTION_REGISTRATION_RECORD, 0);

	StructTy_struct__NT_TIB_fields.push_back(PointerTy_44);
	StructTy_struct__NT_TIB_fields.push_back(Int8PtrTy);
	StructTy_struct__NT_TIB_fields.push_back(Int8PtrTy);
	StructTy_struct__NT_TIB_fields.push_back(Int8PtrTy);
	StructType *StructTy_union_anon = mod->getTypeByName("union.anon");
	if (!StructTy_union_anon) {
		StructTy_union_anon = StructType::create(mod->getContext(), "union.anon");
	}
	std::vector<Type*>StructTy_union_anon_fields;
	StructTy_union_anon_fields.push_back(Int8PtrTy);
	if (StructTy_union_anon->isOpaque()) {
		StructTy_union_anon->setBody(StructTy_union_anon_fields, /*isPacked=*/false);
	}

	StructTy_struct__NT_TIB_fields.push_back(StructTy_union_anon);
	StructTy_struct__NT_TIB_fields.push_back(Int8PtrTy);
	PointerType* PointerTy_43 = PointerType::get(StructTy_struct__NT_TIB, 0);

	StructTy_struct__NT_TIB_fields.push_back(PointerTy_43);
	if (StructTy_struct__NT_TIB->isOpaque()) {
		StructTy_struct__NT_TIB->setBody(StructTy_struct__NT_TIB_fields, /*isPacked=*/false);
	}

	return PointerTy_43;
}

Value* win32CallVirtualFree(Value *addr_to_free, BasicBlock *b) {

	Module *mod = b->getParent()->getParent();
	unsigned regWidth = getPointerSize(mod);

	IntegerType* Int32Ty = IntegerType::get(mod->getContext(), regWidth);
	ConstantInt* const_int32_zero = ConstantInt::get(Int32Ty, 0, false);
	ConstantInt* const_int32_mem_release = ConstantInt::get(Int32Ty, 0x8000, false);

	std::vector<Type*>vfree_ty_args;
	vfree_ty_args.push_back(Int32Ty);
	vfree_ty_args.push_back(Int32Ty);
	vfree_ty_args.push_back(Int32Ty);
	FunctionType* vfree_ty = FunctionType::get(
			/*Result=*/Int32Ty,
			/*Params=*/vfree_ty_args,
			/*isVarArg=*/false);
	Function* func_VirtualFree = mod->getFunction("VirtualFree");
	if (!func_VirtualFree) {
		func_VirtualFree = Function::Create(
				/*Type=*/vfree_ty,
				/*Linkage=*//*GlobalValue::AvailableExternallyLinkage*/GlobalValue::ExternalLinkage,
				/*Name=*/"VirtualFree", mod); // (external, no body)
		func_VirtualFree->setCallingConv(/*CallingConv::X86_StdCall*/getCallingConv(mod));
	}

	std::vector<Value*> vfree_call_params;
	vfree_call_params.push_back(addr_to_free);
	vfree_call_params.push_back(const_int32_zero);
	vfree_call_params.push_back(const_int32_mem_release);
	CallInst* vfree_call = CallInst::Create(
			func_VirtualFree,
			vfree_call_params,
			"",
			b);
	vfree_call->setCallingConv(/*CallingConv::X86_StdCall*/getCallingConv(mod));
	vfree_call->setTailCall(false);
	return vfree_call;
}

static Value* getStackBasePtr(Value *ptr_tib, BasicBlock *b)
{
	Module *mod = b->getParent()->getParent();
	unsigned regWidth = getPointerSize(mod);
	IntegerType* Int32Ty = IntegerType::get(mod->getContext(), 32);

	ConstantInt* const_int32_zero = ConstantInt::get(Int32Ty, 0, false);
	ConstantInt* const_int32_one = ConstantInt::get(Int32Ty, 1, false);

	std::vector<Value*> ptr_257_indices;
	ptr_257_indices.push_back(const_int32_zero); // 0
	ptr_257_indices.push_back(const_int32_one); // 1
	Instruction* ptr_257 = GetElementPtrInst::Create(
			ptr_tib,
			ptr_257_indices,
			"",
			b);
	return ptr_257;
}

Value* win32SetStackBase(Value *ptr_tib, BasicBlock *b, Value *new_base)
{
	Module *mod = b->getParent()->getParent();
	Value *ptr_257 = getStackBasePtr(ptr_tib, b);

	// expects to store i8*, but likely we are getting an int32
	// convert if necessary
	if(new_base->getType()->isPointerTy() == false) {
		PointerType* Int8PtrTy = PointerType::get(IntegerType::get(mod->getContext(), 8), 0);
		new_base = new IntToPtrInst(new_base, Int8PtrTy, "", b);
	}


	StoreInst* stackBase = new StoreInst(new_base, ptr_257, b);
	stackBase->setAlignment(4);

	return stackBase;
}

Value* win32GetStackBase(Value *ptr_tib, BasicBlock *b)
{
	Value *ptr_257 = getStackBasePtr(ptr_tib, b);
	LoadInst* stackBase = new LoadInst(ptr_257, "", false, b);
	stackBase->setAlignment(4);

	return stackBase;
}

static Value* getStackLimitPtr(Value *ptr_tib, BasicBlock *b)
{
	std::vector<Value*> ptr_253_indices;
	Module *mod = b->getParent()->getParent();

	unsigned regWidth = getPointerSize(mod);

	IntegerType* Int32Ty = IntegerType::get(mod->getContext(), 32);

	ConstantInt* const_int32_zero = ConstantInt::get(Int32Ty, 0, false);
	ConstantInt* const_int32_two = ConstantInt::get(Int32Ty, 2, false);

	ptr_253_indices.push_back(const_int32_zero); // 0
	ptr_253_indices.push_back(const_int32_two); // 2
	Instruction* ptr_253 = GetElementPtrInst::Create(ptr_tib,
			ptr_253_indices, "", b);

	return ptr_253;
}

Value* win32SetStackLimit(Value *ptr_tib, BasicBlock *b, Value *new_limit)
{
	Module *mod = b->getParent()->getParent();
	Value *ptr_253 = getStackLimitPtr(ptr_tib, b);
	// expects to store i8*, but likely we are getting an int32
	// convert if necessary
	if(new_limit->getType()->isPointerTy() == false) {
		PointerType* Int8PtrTy = PointerType::get(IntegerType::get(mod->getContext(), 8), 0);
		new_limit = new IntToPtrInst(new_limit, Int8PtrTy, "", b);
	}
	StoreInst* ptr_254 = new StoreInst(new_limit, ptr_253, b);
	ptr_254->setAlignment(4);

	return ptr_254;
}

Value* win32GetStackLimit(Value *ptr_tib, BasicBlock *b)
{
	Value *ptr_253 = getStackLimitPtr(ptr_tib, b);
	LoadInst* ptr_254 = new LoadInst(ptr_253, "", false, b);
	ptr_254->setAlignment(4);

	return ptr_254;
}

Value* win32GetTib(BasicBlock *b) {

	Module *mod = b->getParent()->getParent();

	PointerType* Int8PtrTy = PointerType::get(IntegerType::get(mod->getContext(), 8), 0);
	std::vector<Type*>FuncTy_52_args;
	FunctionType* FuncTy_52 = FunctionType::get(
			/*Result=*/Int8PtrTy,
			/*Params=*/FuncTy_52_args,
			/*isVarArg=*/false);

	// READ The TIB
        InlineAsm* ptr_249 = nullptr;
        if( getSystemArch(mod) == _X86_64_) {
            ptr_249 = InlineAsm::get(FuncTy_52,
                    "movq %gs:0x30, $0", "={rax},~{rax}",
                    true,
                    false, InlineAsm::AD_ATT);
        } else if (getSystemArch(mod) == _X86_) {
            ptr_249 = InlineAsm::get(FuncTy_52,
                    "movl %fs:0x18, $0", "={eax},~{eax}",
                    true,
                    false, InlineAsm::AD_ATT);
        } else {
           std::cerr << "Unknown architecture in triple" << std::endl; 
           TASSERT(false, "Unknown architecture in triple");
        }

	std::vector<Value*> f52_params;
	CallInst* teb_ptr = CallInst::Create(ptr_249, f52_params, "", b);
	CastInst* teb_to_tib = new BitCastInst(teb_ptr, getTibPtrTy(mod), "", b);

	return teb_to_tib;

}

static Value *getAllocationBasePtr(Value *tib_ptr, BasicBlock *b) {
	Module *mod = b->getParent()->getParent();
	unsigned regWidth = getPointerSize(mod);

	IntegerType* IntegerTy = IntegerType::get(mod->getContext(), regWidth);
	PointerType* IntegerPtrTy = PointerType::get(IntegerTy, 0);

	ConstantInt* DeallocationStack = nullptr;
        
        if(regWidth == 32) {
            DeallocationStack = ConstantInt::get(IntegerTy, 0xE0C, false);
        } else {
            DeallocationStack = ConstantInt::get(IntegerTy, 0x1478, false);
        }

	CastInst* intOfTebPtr = new PtrToIntInst(tib_ptr,
			IntegerType::get(mod->getContext(), regWidth),
			"",
			b);
	BinaryOperator* moveTebInt =
			BinaryOperator::Create(Instruction::Add,
					intOfTebPtr,
					DeallocationStack,
					"",
					b);

	CastInst* ptrToAllocBase = new llvm::IntToPtrInst(moveTebInt,
			IntegerPtrTy,
			"",
			b);

	return ptrToAllocBase;

}

Value *win32SetAllocationBase(Value *tib_ptr, BasicBlock *b, Value *new_base) 
{
	Module *mod = b->getParent()->getParent();
	unsigned regWidth = getPointerSize(mod);

	Value *ptrToAllocBase = getAllocationBasePtr(tib_ptr, b);

	// allocation base is an int32
	// so need to convert ptr to int, unlike the other
	// stack related stuff :(
	if(new_base->getType()->isPointerTy() == true) {
		Type* IntegerTy = IntegerType::get(mod->getContext(), regWidth);
		new_base = new PtrToIntInst(new_base, IntegerTy, "", b);
	}

	StoreInst *newAllocBase = new StoreInst(new_base, ptrToAllocBase, b);

	return newAllocBase;
}

Value *win32GetAllocationBase(Value *tib_ptr, BasicBlock *b) {

	Value *ptrToAllocBase = getAllocationBasePtr(tib_ptr, b);
	LoadInst* allocBase = new LoadInst(ptrToAllocBase, "", false, b);

	return allocBase;
}

Value* win32GetStackSize(Value *ptr_tib, BasicBlock *b)
{
	Module *mod = b->getParent()->getParent();
	unsigned regWidth = getPointerSize(mod);
	Value *sb = win32GetStackBase(ptr_tib, b);
	Value *ab = win32GetAllocationBase(ptr_tib, b);
	CastInst* stackBaseInt = new PtrToIntInst(sb,
			IntegerType::get(mod->getContext(), regWidth), "",
			b);
	// stack size = stack base - allocation base
	BinaryOperator* alloc_size_int =
			BinaryOperator::Create(Instruction::Sub, stackBaseInt, ab, "", b);

	return alloc_size_int;
}

Value *win32CallVirtualAlloc(Value *size, BasicBlock *b) {
	Module *mod = b->getParent()->getParent();
	unsigned regWidth = getPointerSize(mod);

	IntegerType* void_ptr_type = IntegerType::get(mod->getContext(), regWidth);
	IntegerType* Int32Ty = IntegerType::get(mod->getContext(), 32);
	IntegerType* SizeTy = IntegerType::get(mod->getContext(), regWidth);
	ConstantInt* const_int32_zero = ConstantInt::get(void_ptr_type, 0, false);
	ConstantInt* const_int32_alloctype = ConstantInt::get(Int32Ty, 0x3000, false);
	ConstantInt* const_int32_pagerw = ConstantInt::get(Int32Ty, 4, false);

	std::vector<Type*>valloc_ty_args;
	valloc_ty_args.push_back(void_ptr_type);
	valloc_ty_args.push_back(SizeTy);
	valloc_ty_args.push_back(Int32Ty);
	valloc_ty_args.push_back(Int32Ty);

	FunctionType* valloc_ty = FunctionType::get(
			/*Result=*/void_ptr_type,
			/*Params=*/valloc_ty_args,
			/*isVarArg=*/false);

	Function* func_VirtualAlloc = mod->getFunction("VirtualAlloc");
	if (!func_VirtualAlloc) {
		func_VirtualAlloc = Function::Create(
				/*Type=*/valloc_ty,
				/*Linkage=*//*GlobalValue::AvailableExternallyLinkage*/ GlobalValue::ExternalLinkage,
				/*Name=*/"VirtualAlloc", mod); // (external, no body)
		func_VirtualAlloc->setCallingConv(/*CallingConv::X86_StdCall*/getCallingConv(mod));
	}



	std::vector<Value*> valloc_params;
	valloc_params.push_back(const_int32_zero); // NULL
	valloc_params.push_back(size); // allocation size
	valloc_params.push_back(const_int32_alloctype); // mem_commit | mem_reserve
	valloc_params.push_back(const_int32_pagerw); // page_readwrite

	// allocate the new stack
	CallInst* valloc_result = CallInst::Create(func_VirtualAlloc, valloc_params, "", b);
	valloc_result->setCallingConv(/*CallingConv::X86_StdCall*/getCallingConv(mod));
	valloc_result->setTailCall(false);

	return valloc_result;
}

FunctionType *getEpilogueType(Module *M) {

	unsigned regWidth = getPointerSize(M);

	Type *voidstar = PointerType::get(
			Type::getInt8Ty(M->getContext()),
			0);
	SmallVector<Type*, 4> epi_args;
	epi_args.push_back(g_PRegStruct);
	epi_args.push_back(voidstar);
	FunctionType    *funcTy = FunctionType::get(
            Type::getIntNTy(M->getContext(), regWidth),
            epi_args,
            false);

	return funcTy;
}

Module* addWin32CallbacksToModule(Module *mod) {

	// Type Definitions
	unsigned regWidth = getPointerSize(mod);

	ArrayType* ArrayTy_0 = ArrayType::get(IntegerType::get(mod->getContext(), 16), 23);
	PointerType* PointerTy_1 = PointerType::get(ArrayTy_0, 0);

	ArrayType* ArrayTy_2 = ArrayType::get(IntegerType::get(mod->getContext(), 16), 28);
	PointerType* PointerTy_3 = PointerType::get(ArrayTy_2, 0);


	std::vector<Type*>FuncTy_9_args;
	StructType *StructTy_struct__nativefpu = mod->getTypeByName("struct._nativefpu");
	if (!StructTy_struct__nativefpu) {
		StructTy_struct__nativefpu = StructType::create(mod->getContext(), "struct._nativefpu");
	}

	std::vector<Type*>StructTy_struct__nativefpu_fields;
	ArrayType* ArrayTy_11 = ArrayType::get(IntegerType::get(mod->getContext(), 8), 12);

	StructTy_struct__nativefpu_fields.push_back(ArrayTy_11);
	if (StructTy_struct__nativefpu->isOpaque()) {
		StructTy_struct__nativefpu->setBody(StructTy_struct__nativefpu_fields, /*isPacked=*/false);
	}

	PointerType* PointerTy_10 = PointerType::get(StructTy_struct__nativefpu, 0);

	FuncTy_9_args.push_back(PointerTy_10);
	StructType *StructTy_struct__RegState = mod->getTypeByName("struct._RegState");
	if (!StructTy_struct__RegState) {
		StructTy_struct__RegState = StructType::create(mod->getContext(), "struct._RegState");
	}

	std::vector<Type*>StructTy_struct__RegState_fields;
	StructTy_struct__RegState_fields.push_back(IntegerType::get(mod->getContext(), regWidth));  //RAX
	StructTy_struct__RegState_fields.push_back(IntegerType::get(mod->getContext(), regWidth));  //RBX
	StructTy_struct__RegState_fields.push_back(IntegerType::get(mod->getContext(), regWidth));  //RCX
	StructTy_struct__RegState_fields.push_back(IntegerType::get(mod->getContext(), regWidth));  //RDX
	StructTy_struct__RegState_fields.push_back(IntegerType::get(mod->getContext(), regWidth));  //RDI
	StructTy_struct__RegState_fields.push_back(IntegerType::get(mod->getContext(), regWidth));  //RSI
	StructTy_struct__RegState_fields.push_back(IntegerType::get(mod->getContext(), regWidth));  //RSP
	StructTy_struct__RegState_fields.push_back(IntegerType::get(mod->getContext(), regWidth));  //RBP
	StructTy_struct__RegState_fields.push_back(IntegerType::get(mod->getContext(), regWidth));
	StructTy_struct__RegState_fields.push_back(IntegerType::get(mod->getContext(), regWidth));
	StructTy_struct__RegState_fields.push_back(IntegerType::get(mod->getContext(), regWidth));
	StructTy_struct__RegState_fields.push_back(IntegerType::get(mod->getContext(), regWidth));
	StructTy_struct__RegState_fields.push_back(IntegerType::get(mod->getContext(), regWidth));
	StructTy_struct__RegState_fields.push_back(IntegerType::get(mod->getContext(), regWidth));
	StructTy_struct__RegState_fields.push_back(IntegerType::get(mod->getContext(), regWidth));

	StructType *StructTy_struct__fpuregs = mod->getTypeByName("struct._fpuregs");
	if (!StructTy_struct__fpuregs) {
		StructTy_struct__fpuregs = StructType::create(mod->getContext(), "struct._fpuregs");
	}

	std::vector<Type*>StructTy_struct__fpuregs_fields;
	ArrayType* ArrayTy_13 = ArrayType::get(StructTy_struct__nativefpu, 8);

	StructTy_struct__fpuregs_fields.push_back(ArrayTy_13);
	if (StructTy_struct__fpuregs->isOpaque()) {
		StructTy_struct__fpuregs->setBody(StructTy_struct__fpuregs_fields, /*isPacked=*/false);
	}

	StructTy_struct__RegState_fields.push_back(StructTy_struct__fpuregs);
	StructType *StructTy_struct__fpuflags = mod->getTypeByName("struct._fpuflags");
	if (!StructTy_struct__fpuflags) {
		StructTy_struct__fpuflags = StructType::create(mod->getContext(), "struct._fpuflags");
	}
	std::vector<Type*>StructTy_struct__fpuflags_fields;
	StructTy_struct__fpuflags_fields.push_back(IntegerType::get(mod->getContext(), regWidth));
	StructTy_struct__fpuflags_fields.push_back(IntegerType::get(mod->getContext(), regWidth));
	StructTy_struct__fpuflags_fields.push_back(IntegerType::get(mod->getContext(), regWidth));
	StructTy_struct__fpuflags_fields.push_back(IntegerType::get(mod->getContext(), regWidth));
	StructTy_struct__fpuflags_fields.push_back(IntegerType::get(mod->getContext(), regWidth));
	StructTy_struct__fpuflags_fields.push_back(IntegerType::get(mod->getContext(), regWidth));
	StructTy_struct__fpuflags_fields.push_back(IntegerType::get(mod->getContext(), regWidth));
	StructTy_struct__fpuflags_fields.push_back(IntegerType::get(mod->getContext(), regWidth));
	StructTy_struct__fpuflags_fields.push_back(IntegerType::get(mod->getContext(), regWidth));
	StructTy_struct__fpuflags_fields.push_back(IntegerType::get(mod->getContext(), regWidth));
	StructTy_struct__fpuflags_fields.push_back(IntegerType::get(mod->getContext(), regWidth));
	StructTy_struct__fpuflags_fields.push_back(IntegerType::get(mod->getContext(), regWidth));
	StructTy_struct__fpuflags_fields.push_back(IntegerType::get(mod->getContext(), regWidth));
	StructTy_struct__fpuflags_fields.push_back(IntegerType::get(mod->getContext(), regWidth));
	if (StructTy_struct__fpuflags->isOpaque()) {
		StructTy_struct__fpuflags->setBody(StructTy_struct__fpuflags_fields, /*isPacked=*/true);
	}

	StructTy_struct__RegState_fields.push_back(StructTy_struct__fpuflags);
	StructType *StructTy_struct__fpucontrol = mod->getTypeByName("struct._fpucontrol");
	if (!StructTy_struct__fpucontrol) {
		StructTy_struct__fpucontrol = StructType::create(mod->getContext(), "struct._fpucontrol");
	}
	std::vector<Type*>StructTy_struct__fpucontrol_fields;
	StructTy_struct__fpucontrol_fields.push_back(IntegerType::get(mod->getContext(), regWidth));
	StructTy_struct__fpucontrol_fields.push_back(IntegerType::get(mod->getContext(), regWidth));
	StructTy_struct__fpucontrol_fields.push_back(IntegerType::get(mod->getContext(), regWidth));
	StructTy_struct__fpucontrol_fields.push_back(IntegerType::get(mod->getContext(), regWidth));
	StructTy_struct__fpucontrol_fields.push_back(IntegerType::get(mod->getContext(), regWidth));
	StructTy_struct__fpucontrol_fields.push_back(IntegerType::get(mod->getContext(), regWidth));
	StructTy_struct__fpucontrol_fields.push_back(IntegerType::get(mod->getContext(), regWidth));
	StructTy_struct__fpucontrol_fields.push_back(IntegerType::get(mod->getContext(), regWidth));
	StructTy_struct__fpucontrol_fields.push_back(IntegerType::get(mod->getContext(), regWidth));
	if (StructTy_struct__fpucontrol->isOpaque()) {
		StructTy_struct__fpucontrol->setBody(StructTy_struct__fpucontrol_fields, /*isPacked=*/true);
	}

	StructTy_struct__RegState_fields.push_back(StructTy_struct__fpucontrol);
	StructType *StructTy_struct__fputag = mod->getTypeByName("struct._fputag");
	if (!StructTy_struct__fputag) {
		StructTy_struct__fputag = StructType::create(mod->getContext(), "struct._fputag");
	}
	std::vector<Type*>StructTy_struct__fputag_fields;
	ArrayType* ArrayTy_14 = ArrayType::get(IntegerType::get(mod->getContext(), 8), 8);

	StructTy_struct__fputag_fields.push_back(ArrayTy_14);
	if (StructTy_struct__fputag->isOpaque()) {
		StructTy_struct__fputag->setBody(StructTy_struct__fputag_fields, /*isPacked=*/false);
	}

	StructTy_struct__RegState_fields.push_back(StructTy_struct__fputag);
	StructType *StructTy_struct__segmentoffset = mod->getTypeByName("struct._segmentoffset");
	if (!StructTy_struct__segmentoffset) {
		StructTy_struct__segmentoffset = StructType::create(mod->getContext(), "struct._segmentoffset");
	}
	std::vector<Type*>StructTy_struct__segmentoffset_fields;
	StructTy_struct__segmentoffset_fields.push_back(IntegerType::get(mod->getContext(), 32));
	StructTy_struct__segmentoffset_fields.push_back(IntegerType::get(mod->getContext(), 32));
	if (StructTy_struct__segmentoffset->isOpaque()) {
		StructTy_struct__segmentoffset->setBody(StructTy_struct__segmentoffset_fields, /*isPacked=*/true);
	}

	StructTy_struct__RegState_fields.push_back(StructTy_struct__segmentoffset);
	StructTy_struct__RegState_fields.push_back(StructTy_struct__segmentoffset);
	StructTy_struct__RegState_fields.push_back(IntegerType::get(mod->getContext(), regWidth));
	StructType *StructTy_struct__xmmregstate = mod->getTypeByName("struct._xmmregstate");
	if (!StructTy_struct__xmmregstate) {
		StructTy_struct__xmmregstate = StructType::create(mod->getContext(), "struct._xmmregstate");
	}
	std::vector<Type*>StructTy_struct__xmmregstate_fields;
	ArrayType* ArrayTy_15 = ArrayType::get(IntegerType::get(mod->getContext(), 8), 16);

	StructTy_struct__xmmregstate_fields.push_back(ArrayTy_15);
	if (StructTy_struct__xmmregstate->isOpaque()) {
		StructTy_struct__xmmregstate->setBody(StructTy_struct__xmmregstate_fields, /*isPacked=*/false);
	}

	StructTy_struct__RegState_fields.push_back(StructTy_struct__xmmregstate);
	StructTy_struct__RegState_fields.push_back(StructTy_struct__xmmregstate);
	StructTy_struct__RegState_fields.push_back(StructTy_struct__xmmregstate);
	StructTy_struct__RegState_fields.push_back(StructTy_struct__xmmregstate);
	StructTy_struct__RegState_fields.push_back(StructTy_struct__xmmregstate);
	StructTy_struct__RegState_fields.push_back(StructTy_struct__xmmregstate);
	StructTy_struct__RegState_fields.push_back(StructTy_struct__xmmregstate);
	StructTy_struct__RegState_fields.push_back(StructTy_struct__xmmregstate);
	if (StructTy_struct__RegState->isOpaque()) {
		StructTy_struct__RegState->setBody(StructTy_struct__RegState_fields, /*isPacked=*/true);
	}

	PointerType* PointerTy_12 = PointerType::get(StructTy_struct__RegState, 0);

	FuncTy_9_args.push_back(PointerTy_12);
	FuncTy_9_args.push_back(IntegerType::get(mod->getContext(), regWidth));
	FunctionType* FuncTy_9 = FunctionType::get(
			/*Result=*/Type::getVoidTy(mod->getContext()),
			/*Params=*/FuncTy_9_args,
			/*isVarArg=*/false);

	PointerType* PointerTy_16 = PointerType::get(PointerTy_12, 0);

	PointerType* PointerTy_17 = PointerType::get(StructTy_struct__fpuflags, 0);

	PointerType* PointerTy_18 = PointerType::get(IntegerType::get(mod->getContext(), 16), 0);

	std::vector<Type*>FuncTy_20_args;
	FuncTy_20_args.push_back(PointerTy_18);
	FuncTy_20_args.push_back(PointerTy_18);
	FuncTy_20_args.push_back(IntegerType::get(mod->getContext(), 32));
	FunctionType* FuncTy_20 = FunctionType::get(
			/*Result=*/Type::getVoidTy(mod->getContext()),
			/*Params=*/FuncTy_20_args,
			/*isVarArg=*/false);

	PointerType* PointerTy_19 = PointerType::get(FuncTy_20, 0);

	PointerType* PointerTy_21 = PointerType::get(StructTy_struct__fpuregs, 0);

	PointerType* PointerTy_22 = PointerType::get(ArrayTy_13, 0);

	PointerType* Int8PtrTy = PointerType::get(IntegerType::get(mod->getContext(), 8), 0);
	PointerType* Int32PtrTy = PointerType::get(IntegerType::get(mod->getContext(), 32), 0);
	IntegerType* Int32Ty = IntegerType::get(mod->getContext(), regWidth);

	std::vector<Type*>FuncTy_25_args;
	FuncTy_25_args.push_back(Int8PtrTy);
	FuncTy_25_args.push_back(Int8PtrTy);
	FuncTy_25_args.push_back(IntegerType::get(mod->getContext(), regWidth));
	FuncTy_25_args.push_back(IntegerType::get(mod->getContext(), 32));
	FuncTy_25_args.push_back(IntegerType::get(mod->getContext(), 1));
	FunctionType* FuncTy_25 = FunctionType::get(
			/*Result=*/Type::getVoidTy(mod->getContext()),
			/*Params=*/FuncTy_25_args,
			/*isVarArg=*/false);

	PointerType* PointerTy_24 = PointerType::get(FuncTy_25, 0);

	std::vector<Type*>FuncTy_26_args;
	FuncTy_26_args.push_back(PointerTy_12);
	FuncTy_26_args.push_back(IntegerType::get(mod->getContext(), regWidth));
	FuncTy_26_args.push_back(PointerTy_10);
	FunctionType* FuncTy_26 = FunctionType::get(
			/*Result=*/Type::getVoidTy(mod->getContext()),
			/*Params=*/FuncTy_26_args,
			/*isVarArg=*/false);

	std::vector<Type*>FuncTy_27_args;
	FuncTy_27_args.push_back(PointerTy_10);
	FunctionType* FuncTy_27 = FunctionType::get(
			/*Result=*/Type::getDoubleTy(mod->getContext()),
			/*Params=*/FuncTy_27_args,
			/*isVarArg=*/false);

	PointerType* PointerTy_28 = PointerType::get(PointerTy_10, 0);

	PointerType* PointerTy_29 = PointerType::get(Type::getDoubleTy(mod->getContext()), 0);

	std::vector<Type*>FuncTy_31_args;
	FuncTy_31_args.push_back(PointerTy_28);
	FuncTy_31_args.push_back(PointerTy_29);
	FunctionType* FuncTy_31 = FunctionType::get(
			/*Result=*/Type::getVoidTy(mod->getContext()),
			/*Params=*/FuncTy_31_args,
			/*isVarArg=*/false);

	PointerType* PointerTy_30 = PointerType::get(FuncTy_31, 0);

	std::vector<Type*>FuncTy_32_args;
	FuncTy_32_args.push_back(Type::getDoubleTy(mod->getContext()));
	FuncTy_32_args.push_back(PointerTy_10);
	FunctionType* FuncTy_32 = FunctionType::get(
			/*Result=*/Type::getVoidTy(mod->getContext()),
			/*Params=*/FuncTy_32_args,
			/*isVarArg=*/false);

	std::vector<Type*>FuncTy_34_args;
	FuncTy_34_args.push_back(PointerTy_29);
	FuncTy_34_args.push_back(PointerTy_28);
	FunctionType* FuncTy_34 = FunctionType::get(
			/*Result=*/Type::getVoidTy(mod->getContext()),
			/*Params=*/FuncTy_34_args,
			/*isVarArg=*/false);

	PointerType* PointerTy_33 = PointerType::get(FuncTy_34, 0);

	std::vector<Type*>FuncTy_35_args;
	PointerType* PointerTy_36 = PointerType::get(Int8PtrTy, 0);

	FuncTy_35_args.push_back(PointerTy_36);
	FunctionType* FuncTy_35 = FunctionType::get(
			/*Result=*/PointerTy_12,
			/*Params=*/FuncTy_35_args,
			/*isVarArg=*/false);

	PointerType* PointerTy_37 = PointerType::get(PointerTy_36, 0);

	std::vector<Type*>FuncTy_39_args;
	FuncTy_39_args.push_back(IntegerType::get(mod->getContext(), regWidth));
	FuncTy_39_args.push_back(Int8PtrTy);
	FuncTy_39_args.push_back(PointerTy_36);
	FunctionType* FuncTy_39 = FunctionType::get(
			/*Result=*/PointerTy_12,
			/*Params=*/FuncTy_39_args,
			/*isVarArg=*/false);

	PointerType* PointerTy_38 = PointerType::get(FuncTy_39, 0);

	std::vector<Type*>FuncTy_41_args;
	FuncTy_41_args.push_back(PointerTy_36);
	FuncTy_41_args.push_back(PointerTy_38);
	FunctionType* FuncTy_41 = FunctionType::get(
			///*Result=*/Type::getVoidTy(mod->getContext()),
			/*Result=*/g_PRegStruct,
			/*Params=*/FuncTy_41_args,
			/*isVarArg=*/false);

	PointerType* PointerTy_40 = PointerType::get(FuncTy_41, 0);


	std::vector<Type*>FuncTy_52_args;
	FunctionType* FuncTy_52 = FunctionType::get(
			/*Result=*/Int8PtrTy,
			/*Params=*/FuncTy_52_args,
			/*isVarArg=*/false);

	// function type for malloc
	std::vector<Type*>FuncTy_56_args;
	FuncTy_56_args.push_back(IntegerType::get(mod->getContext(), regWidth));
	FunctionType* FuncTy_56 = FunctionType::get(
			/*Result=*/Int32Ty,
			/*Params=*/FuncTy_56_args,
			/*isVarArg=*/false);

	PointerType* PointerTy_55 = PointerType::get(FuncTy_56, 0);

	std::vector<Type*>FuncTy_57_args;
	FuncTy_57_args.push_back(PointerTy_12);
	FuncTy_57_args.push_back(Int8PtrTy);
	FunctionType* FuncTy_57 = FunctionType::get(
			/*Result=*/IntegerType::get(mod->getContext(), 32),
			/*Params=*/FuncTy_57_args,
			/*isVarArg=*/false);


	std::vector<Type*>FuncTy_61_args;
	FuncTy_61_args.push_back(Int32Ty);
	FunctionType* FuncTy_61 = FunctionType::get(
			/*Result=*/Type::getVoidTy(mod->getContext()),
			/*Params=*/FuncTy_61_args,
			/*isVarArg=*/false);

	PointerType* PointerTy_60 = PointerType::get(FuncTy_61, 0);


	Function* func_FPU_GET_REG = mod->getFunction("FPU_GET_REG");
	if (!func_FPU_GET_REG) {
		func_FPU_GET_REG = Function::Create(
				/*Type=*/FuncTy_9,
				/*Linkage=*/GlobalValue::InternalLinkage,
				/*Name=*/"FPU_GET_REG", mod);
		func_FPU_GET_REG->setCallingConv(CallingConv::C);
	}
	AttributeSet func_FPU_GET_REG_PAL;
	func_FPU_GET_REG_PAL = func_FPU_GET_REG_PAL.addAttribute(mod->getContext(), 1U, Attribute::StructRet);
	func_FPU_GET_REG_PAL = func_FPU_GET_REG_PAL.addAttribute(mod->getContext(), 1U, Attribute::NoAlias);
	func_FPU_GET_REG_PAL = func_FPU_GET_REG_PAL.addAttribute(mod->getContext(), ~0U, Attribute::NoUnwind);

	func_FPU_GET_REG->setAttributes(func_FPU_GET_REG_PAL);

	Function* func__wassert = mod->getFunction("_wassert");
	if (!func__wassert) {
		func__wassert = Function::Create(
				/*Type=*/FuncTy_20,
				/*Linkage=*/GlobalValue::ExternalLinkage,
				/*Name=*/"_wassert", mod); // (external, no body)
		func__wassert->setCallingConv(CallingConv::C);
	}

	Function* func_llvm_memcpy_p0i8_p0i8_i32 = mod->getFunction("llvm.memcpy.p0i8.p0i8.i64");
	if (!func_llvm_memcpy_p0i8_p0i8_i32) {
		func_llvm_memcpy_p0i8_p0i8_i32 = Function::Create(
				/*Type=*/FuncTy_25,
				/*Linkage=*/GlobalValue::ExternalLinkage,
				/*Name=*/"llvm.memcpy.p0i8.p0i8.i64", mod); // (external, no body)
		func_llvm_memcpy_p0i8_p0i8_i32->setCallingConv(CallingConv::C);
	}
	AttributeSet func_llvm_memcpy_p0i8_p0i8_i32_PAL;
	func_llvm_memcpy_p0i8_p0i8_i32_PAL = func_llvm_memcpy_p0i8_p0i8_i32_PAL.addAttribute(
			mod->getContext(), 1U, Attribute::NoCapture);

	func_llvm_memcpy_p0i8_p0i8_i32_PAL = func_llvm_memcpy_p0i8_p0i8_i32_PAL.addAttribute(
			mod->getContext(), 2U, Attribute::NoCapture);

	func_llvm_memcpy_p0i8_p0i8_i32_PAL = func_llvm_memcpy_p0i8_p0i8_i32_PAL.addAttribute(
			mod->getContext(), ~0U, Attribute::NoUnwind);

	func_llvm_memcpy_p0i8_p0i8_i32->setAttributes(func_llvm_memcpy_p0i8_p0i8_i32_PAL);

	Function* func_FPU_SET_REG = mod->getFunction("FPU_SET_REG");
	if (!func_FPU_SET_REG) {
		func_FPU_SET_REG = Function::Create(
				/*Type=*/FuncTy_26,
				/*Linkage=*/GlobalValue::InternalLinkage,
				/*Name=*/"FPU_SET_REG", mod);
		func_FPU_SET_REG->setCallingConv(CallingConv::C);
	}
	AttributeSet func_FPU_SET_REG_PAL;
	func_FPU_SET_REG_PAL = func_FPU_SET_REG_PAL.addAttribute(mod->getContext(), 3U, Attribute::ByVal);
	func_FPU_SET_REG_PAL = func_FPU_SET_REG_PAL.addAttribute(mod->getContext(), ~0U, Attribute::NoUnwind);

	func_FPU_SET_REG->setAttributes(func_FPU_SET_REG_PAL);

	Function* func_NATIVEFPU_TO_LD = mod->getFunction("NATIVEFPU_TO_LD");
	if (!func_NATIVEFPU_TO_LD) {
		func_NATIVEFPU_TO_LD = Function::Create(
				/*Type=*/FuncTy_27,
				/*Linkage=*/GlobalValue::InternalLinkage,
				/*Name=*/"NATIVEFPU_TO_LD", mod);
		func_NATIVEFPU_TO_LD->setCallingConv(CallingConv::C);
	}
	AttributeSet func_NATIVEFPU_TO_LD_PAL;
	func_NATIVEFPU_TO_LD_PAL = func_NATIVEFPU_TO_LD_PAL.addAttribute(mod->getContext(), ~0U, Attribute::NoUnwind);
	func_NATIVEFPU_TO_LD->setAttributes(func_NATIVEFPU_TO_LD_PAL);

	Function* func_LD_TO_NATIVEFPU = mod->getFunction("LD_TO_NATIVEFPU");
	if (!func_LD_TO_NATIVEFPU) {
		func_LD_TO_NATIVEFPU = Function::Create(
				/*Type=*/FuncTy_32,
				/*Linkage=*/GlobalValue::InternalLinkage,
				/*Name=*/"LD_TO_NATIVEFPU", mod);
		func_LD_TO_NATIVEFPU->setCallingConv(CallingConv::C);
	}
	AttributeSet func_LD_TO_NATIVEFPU_PAL;
	func_LD_TO_NATIVEFPU_PAL = func_LD_TO_NATIVEFPU_PAL.addAttribute(mod->getContext(), ~0U, Attribute::NoUnwind);
	func_LD_TO_NATIVEFPU->setAttributes(func_LD_TO_NATIVEFPU_PAL);

	Function* func_callback_adapter_prologue_internal = mod->getFunction("callback_adapter_prologue_internal");
	if (!func_callback_adapter_prologue_internal) {
		func_callback_adapter_prologue_internal = Function::Create(
				/*Type=*/FuncTy_39,
				/*Linkage=*/GlobalValue::InternalLinkage,
				/*Name=*/"callback_adapter_prologue_internal", mod);
		func_callback_adapter_prologue_internal->setCallingConv(/*CallingConv::X86_StdCall*/ getCallingConv(mod));
	}
	AttributeSet func_callback_adapter_prologue_internal_PAL;
	func_callback_adapter_prologue_internal_PAL = func_callback_adapter_prologue_internal_PAL.addAttribute(
			mod->getContext(),
			~0U,
			Attribute::NoUnwind);
	func_callback_adapter_prologue_internal->setAttributes(func_callback_adapter_prologue_internal_PAL);

	Function* func_callback_adapter_epilogue = mod->getFunction("callback_adapter_epilogue");
	if (!func_callback_adapter_epilogue) {
		func_callback_adapter_epilogue = Function::Create(
				///*Type=*/FuncTy_57,
				getEpilogueType(mod),
				/*Linkage=*/GlobalValue::InternalLinkage,
				/*Name=*/"callback_adapter_epilogue", mod);
		func_callback_adapter_epilogue->setCallingConv(/*CallingConv::X86_StdCall*/getCallingConv(mod));
	}

	AttributeSet func_callback_adapter_epilogue_PAL;
	func_callback_adapter_epilogue_PAL = func_callback_adapter_epilogue_PAL.addAttribute(
			mod->getContext(),
			~0U,
			Attribute::NoUnwind);

	func_callback_adapter_epilogue->setAttributes(func_callback_adapter_epilogue_PAL);


	Function* func_free = mod->getFunction("free");
	if (!func_free) {
		func_free = Function::Create(
				/*Type=*/FuncTy_61,
				/*Linkage=*/GlobalValue::ExternalLinkage,
				/*Name=*/"free", mod); // (external, no body)
		func_free->setCallingConv(CallingConv::C);
	}


	Function* func_malloc = mod->getFunction("malloc");
        if (!func_malloc) {
            func_malloc = Function::Create(
                    /*Type=*/FuncTy_56,
                    /*Linkage=*/GlobalValue::ExternalLinkage,
                    /*Name=*/"malloc", mod); // (external, no body)
            if( getSystemArch(mod) == _X86_64_) {
                func_malloc->setCallingConv(CallingConv::X86_64_Win64);
            } else {
                func_malloc->setCallingConv(CallingConv::C);
            }
        }

	// Global Variable Declarations


	GlobalVariable* gvar_array__str = new GlobalVariable(/*Module=*/*mod,
			/*Type=*/ArrayTy_0,
			/*isConstant=*/true,
			/*Linkage=*/GlobalValue::PrivateLinkage,
			/*Initializer=*/0, // has initializer, specified below
	/*Name=*/".str");
	gvar_array__str->setAlignment(2);

	GlobalVariable* gvar_array__str1 = new GlobalVariable(/*Module=*/*mod,
			/*Type=*/ArrayTy_2,
			/*isConstant=*/true,
			/*Linkage=*/GlobalValue::PrivateLinkage,
			/*Initializer=*/0, // has initializer, specified below
	/*Name=*/".str1");
	gvar_array__str1->setAlignment(2);

	GlobalVariable* gvar_array__str2 = new GlobalVariable(/*Module=*/*mod,
			/*Type=*/ArrayTy_0,
			/*isConstant=*/true,
			/*Linkage=*/GlobalValue::PrivateLinkage,
			/*Initializer=*/0, // has initializer, specified below
	/*Name=*/".str2");
	gvar_array__str2->setAlignment(2);

	GlobalVariable* gvar_array__str3 = new GlobalVariable(/*Module=*/*mod,
			/*Type=*/ArrayTy_2,
			/*isConstant=*/true,
			/*Linkage=*/GlobalValue::PrivateLinkage,
			/*Initializer=*/0, // has initializer, specified below
	/*Name=*/".str3");
	gvar_array__str3->setAlignment(2);

	// Constant Definitions
	std::vector<Constant*> const_array_62_elems;
	ConstantInt* const_int16_63 = ConstantInt::get(mod->getContext(), APInt(16, StringRef("114"), 10));
	const_array_62_elems.push_back(const_int16_63);
	ConstantInt* const_int16_64 = ConstantInt::get(mod->getContext(), APInt(16, StringRef("101"), 10));
	const_array_62_elems.push_back(const_int16_64);
	ConstantInt* const_int16_65 = ConstantInt::get(mod->getContext(), APInt(16, StringRef("103"), 10));
	const_array_62_elems.push_back(const_int16_65);
	ConstantInt* const_int16_66 = ConstantInt::get(mod->getContext(), APInt(16, StringRef("95"), 10));
	const_array_62_elems.push_back(const_int16_66);
	ConstantInt* const_int16_67 = ConstantInt::get(mod->getContext(), APInt(16, StringRef("105"), 10));
	const_array_62_elems.push_back(const_int16_67);
	ConstantInt* const_int16_68 = ConstantInt::get(mod->getContext(), APInt(16, StringRef("110"), 10));
	const_array_62_elems.push_back(const_int16_68);
	ConstantInt* const_int16_69 = ConstantInt::get(mod->getContext(), APInt(16, StringRef("100"), 10));
	const_array_62_elems.push_back(const_int16_69);
	const_array_62_elems.push_back(const_int16_64);
	ConstantInt* const_int16_70 = ConstantInt::get(mod->getContext(), APInt(16, StringRef("120"), 10));
	const_array_62_elems.push_back(const_int16_70);
	ConstantInt* const_int16_71 = ConstantInt::get(mod->getContext(), APInt(16, StringRef("32"), 10));
	const_array_62_elems.push_back(const_int16_71);
	ConstantInt* const_int16_72 = ConstantInt::get(mod->getContext(), APInt(16, StringRef("60"), 10));
	const_array_62_elems.push_back(const_int16_72);
	const_array_62_elems.push_back(const_int16_71);
	ConstantInt* const_int16_73 = ConstantInt::get(mod->getContext(), APInt(16, StringRef("83"), 10));
	const_array_62_elems.push_back(const_int16_73);
	ConstantInt* const_int16_74 = ConstantInt::get(mod->getContext(), APInt(16, StringRef("84"), 10));
	const_array_62_elems.push_back(const_int16_74);
	ConstantInt* const_int16_75 = ConstantInt::get(mod->getContext(), APInt(16, StringRef("82"), 10));
	const_array_62_elems.push_back(const_int16_75);
	ConstantInt* const_int16_76 = ConstantInt::get(mod->getContext(), APInt(16, StringRef("69"), 10));
	const_array_62_elems.push_back(const_int16_76);
	ConstantInt* const_int16_77 = ConstantInt::get(mod->getContext(), APInt(16, StringRef("71"), 10));
	const_array_62_elems.push_back(const_int16_77);
	const_array_62_elems.push_back(const_int16_73);
	const_array_62_elems.push_back(const_int16_66);
	ConstantInt* const_int16_78 = ConstantInt::get(mod->getContext(), APInt(16, StringRef("77"), 10));
	const_array_62_elems.push_back(const_int16_78);
	ConstantInt* const_int16_79 = ConstantInt::get(mod->getContext(), APInt(16, StringRef("65"), 10));
	const_array_62_elems.push_back(const_int16_79);
	ConstantInt* const_int16_80 = ConstantInt::get(mod->getContext(), APInt(16, StringRef("88"), 10));
	const_array_62_elems.push_back(const_int16_80);
	ConstantInt* const_int16_81 = ConstantInt::get(mod->getContext(), APInt(16, StringRef("0"), 10));
	const_array_62_elems.push_back(const_int16_81);
	Constant* const_array_62 = ConstantArray::get(ArrayTy_0, const_array_62_elems);
	std::vector<Constant*> const_array_82_elems;
	ConstantInt* const_int16_83 = ConstantInt::get(mod->getContext(), APInt(16, StringRef("46"), 10));
	const_array_82_elems.push_back(const_int16_83);
	ConstantInt* const_int16_84 = ConstantInt::get(mod->getContext(), APInt(16, StringRef("47"), 10));
	const_array_82_elems.push_back(const_int16_84);
	const_array_82_elems.push_back(const_int16_83);
	const_array_82_elems.push_back(const_int16_83);
	const_array_82_elems.push_back(const_int16_84);
	ConstantInt* const_int16_85 = ConstantInt::get(mod->getContext(), APInt(16, StringRef("99"), 10));
	const_array_82_elems.push_back(const_int16_85);
	ConstantInt* const_int16_86 = ConstantInt::get(mod->getContext(), APInt(16, StringRef("111"), 10));
	const_array_82_elems.push_back(const_int16_86);
	ConstantInt* const_int16_87 = ConstantInt::get(mod->getContext(), APInt(16, StringRef("109"), 10));
	const_array_82_elems.push_back(const_int16_87);
	const_array_82_elems.push_back(const_int16_87);
	const_array_82_elems.push_back(const_int16_86);
	const_array_82_elems.push_back(const_int16_68);
	const_array_82_elems.push_back(const_int16_84);
	const_array_82_elems.push_back(const_int16_75);
	const_array_82_elems.push_back(const_int16_64);
	const_array_82_elems.push_back(const_int16_65);
	const_array_82_elems.push_back(const_int16_67);
	ConstantInt* const_int16_88 = ConstantInt::get(mod->getContext(), APInt(16, StringRef("115"), 10));
	const_array_82_elems.push_back(const_int16_88);
	ConstantInt* const_int16_89 = ConstantInt::get(mod->getContext(), APInt(16, StringRef("116"), 10));
	const_array_82_elems.push_back(const_int16_89);
	const_array_82_elems.push_back(const_int16_64);
	const_array_82_elems.push_back(const_int16_63);
	const_array_82_elems.push_back(const_int16_73);
	const_array_82_elems.push_back(const_int16_89);
	ConstantInt* const_int16_90 = ConstantInt::get(mod->getContext(), APInt(16, StringRef("97"), 10));
	const_array_82_elems.push_back(const_int16_90);
	const_array_82_elems.push_back(const_int16_89);
	const_array_82_elems.push_back(const_int16_64);
	const_array_82_elems.push_back(const_int16_83);
	ConstantInt* const_int16_91 = ConstantInt::get(mod->getContext(), APInt(16, StringRef("104"), 10));
	const_array_82_elems.push_back(const_int16_91);
	const_array_82_elems.push_back(const_int16_81);
	Constant* const_array_82 = ConstantArray::get(ArrayTy_2, const_array_82_elems);
	ConstantInt* const_int32_one = ConstantInt::get(mod->getContext(), APInt(32, StringRef("1"), 10));
	ConstantInt* const_int32_zero = ConstantInt::get(mod->getContext(), APInt(32, StringRef("0"), 10));
	ConstantInt* const_int32_sixteen = ConstantInt::get(mod->getContext(), APInt(32, StringRef("16"), 10));
	ConstantInt* const_int32_two = ConstantInt::get(mod->getContext(), APInt(32, StringRef("2"), 10));
	ConstantInt* const_int32_eight = ConstantInt::get(mod->getContext(), APInt(regWidth, StringRef("8"), 10));
	std::vector<Constant*> const_ptr_97_indices;
	const_ptr_97_indices.push_back(const_int32_zero);
	const_ptr_97_indices.push_back(const_int32_zero);
	Constant* const_ptr_97 = ConstantExpr::getGetElementPtr(gvar_array__str, const_ptr_97_indices);
	std::vector<Constant*> const_ptr_98_indices;
	const_ptr_98_indices.push_back(const_int32_zero);
	const_ptr_98_indices.push_back(const_int32_zero);
	Constant* const_ptr_98 = ConstantExpr::getGetElementPtr(gvar_array__str1, const_ptr_98_indices);
	ConstantInt* const_int32_99 = ConstantInt::get(mod->getContext(), APInt(32, StringRef("420"), 10));
	ConstantInt* const_int1_100 = ConstantInt::get(mod->getContext(), APInt(1, StringRef("-1"), 10));
	ConstantInt* const_int1_101 = ConstantInt::get(mod->getContext(), APInt(1, StringRef("0"), 10));
	ConstantInt* const_int32_102 = ConstantInt::get(mod->getContext(), APInt(32, StringRef("15"), 10));
	ConstantInt* const_int32_103 = ConstantInt::get(mod->getContext(), APInt(regWidth, StringRef("12"), 10));
	std::vector<Constant*> const_ptr_104_indices;
	const_ptr_104_indices.push_back(const_int32_zero);
	const_ptr_104_indices.push_back(const_int32_zero);
	Constant* const_ptr_104 = ConstantExpr::getGetElementPtr(gvar_array__str2, const_ptr_104_indices);
	std::vector<Constant*> const_ptr_105_indices;
	const_ptr_105_indices.push_back(const_int32_zero);
	const_ptr_105_indices.push_back(const_int32_zero);
	Constant* const_ptr_105 = ConstantExpr::getGetElementPtr(gvar_array__str3, const_ptr_105_indices);
	ConstantInt* const_int32_106 = ConstantInt::get(mod->getContext(), APInt(32, StringRef("432"), 10));

	// get in memory size of struct regs, as it may be extended
	llvm::DataLayout dl(mod);
	uint64_t reg_state_size = dl.getTypeAllocSize(g_RegStruct);

	ConstantInt* const_int32_110 = ConstantInt::get(Int32Ty, reg_state_size, false);
	ConstantInt* const_int32_111 = ConstantInt::get(mod->getContext(), APInt(32, StringRef("6"), 10));
	ConstantInt* const_int32_112 = ConstantInt::get(mod->getContext(), APInt(32, StringRef("7"), 10));

	// Global Variable Definitions
	gvar_array__str->setInitializer(const_array_62);
	gvar_array__str1->setInitializer(const_array_82);
	gvar_array__str2->setInitializer(const_array_62);
	gvar_array__str3->setInitializer(const_array_82);

	// Function Definitions


	// Function: FPU_GET_REG (func_FPU_GET_REG)
	{
		Function::arg_iterator args = func_FPU_GET_REG->arg_begin();
		Value* ptr_agg_result = args++;
		ptr_agg_result->setName("agg.result");
		Value* ptr_state = args++;
		ptr_state->setName("state");
		Value* int32_reg_index = args++;
		int32_reg_index->setName("reg_index");

		BasicBlock* label_148 = BasicBlock::Create(mod->getContext(), "",func_FPU_GET_REG,0);
		BasicBlock* label_149 = BasicBlock::Create(mod->getContext(), "",func_FPU_GET_REG,0);
		BasicBlock* label_150 = BasicBlock::Create(mod->getContext(), "",func_FPU_GET_REG,0);

		// Block  (label_148)
		AllocaInst* ptr_151 = new AllocaInst(PointerTy_12, "", label_148);
		ptr_151->setAlignment(4);
		AllocaInst* ptr_152 = new AllocaInst(IntegerType::get(mod->getContext(), regWidth), "", label_148);
		ptr_152->setAlignment(4);
		AllocaInst* ptr_rnum = new AllocaInst(IntegerType::get(mod->getContext(), regWidth), "rnum", label_148);
		ptr_rnum->setAlignment(4);
		StoreInst* void_153 = new StoreInst(ptr_state, ptr_151, false, label_148);
		void_153->setAlignment(4);
		StoreInst* void_154 = new StoreInst(int32_reg_index, ptr_152, false, label_148);
		void_154->setAlignment(4);
		LoadInst* ptr_155 = new LoadInst(ptr_151, "", false, label_148);
		ptr_155->setAlignment(4);

		std::vector<Value*> ptr_156_indices;
		ptr_156_indices.push_back(const_int32_zero);
		ptr_156_indices.push_back(const_int32_sixteen);
		Instruction* ptr_156 = GetElementPtrInst::Create(ptr_155, ptr_156_indices, "", label_148);

		std::vector<Value*> ptr_157_indices;
		ptr_157_indices.push_back(const_int32_zero);
		ptr_157_indices.push_back(const_int32_two);
		Instruction* ptr_157 = GetElementPtrInst::Create(ptr_156, ptr_157_indices, "", label_148);
		LoadInst* int32_158 = new LoadInst(ptr_157, "", false, label_148);
		int32_158->setAlignment(1);
		LoadInst* int32_159 = new LoadInst(ptr_152, "", false, label_148);
		int32_159->setAlignment(4);
		BinaryOperator* int32_160 = BinaryOperator::Create(Instruction::Add, int32_158, int32_159, "", label_148);
		StoreInst* void_161 = new StoreInst(int32_160, ptr_rnum, false, label_148);
		void_161->setAlignment(4);
		LoadInst* int32_162 = new LoadInst(ptr_152, "", false, label_148);
		int32_162->setAlignment(4);
		ICmpInst* int1_163 = new ICmpInst(*label_148, ICmpInst::ICMP_ULT, int32_162, const_int32_eight, "");
		BranchInst::Create(label_150, label_149, int1_163, label_148);

		// Block  (label_149)
		std::vector<Value*> void_165_params;
		void_165_params.push_back(const_ptr_97);
		void_165_params.push_back(const_ptr_98);
		void_165_params.push_back(const_int32_99);
		CallInst* void_165 = CallInst::Create(func__wassert, void_165_params, "", label_149);
		void_165->setCallingConv(CallingConv::C);
		void_165->setTailCall(false);

		BranchInst::Create(label_150, label_149);

		// Block  (label_150)
		PHINode* int1_167 = PHINode::Create(IntegerType::get(mod->getContext(), 1), 2, "", label_150);
		int1_167->addIncoming(const_int1_100, label_148);
		int1_167->addIncoming(const_int1_101, label_149);

		CastInst* int32_168 = new ZExtInst(int1_167, IntegerType::get(mod->getContext(), 32), "", label_150);
		LoadInst* int32_169 = new LoadInst(ptr_rnum, "", false, label_150);
		int32_169->setAlignment(4);
		BinaryOperator* int32_170 = BinaryOperator::Create(Instruction::URem, int32_169, const_int32_eight, "", label_150);
		StoreInst* void_171 = new StoreInst(int32_170, ptr_rnum, false, label_150);
		void_171->setAlignment(4);
		LoadInst* int32_172 = new LoadInst(ptr_rnum, "", false, label_150);
		int32_172->setAlignment(4);
		LoadInst* ptr_173 = new LoadInst(ptr_151, "", false, label_150);
		ptr_173->setAlignment(4);
		std::vector<Value*> ptr_174_indices;
		ptr_174_indices.push_back(const_int32_zero);
		ptr_174_indices.push_back(const_int32_102);
		Instruction* ptr_174 = GetElementPtrInst::Create(ptr_173, ptr_174_indices, "", label_150);
		std::vector<Value*> ptr_175_indices;
		ptr_175_indices.push_back(const_int32_zero);
		ptr_175_indices.push_back(const_int32_zero);
		Instruction* ptr_175 = GetElementPtrInst::Create(ptr_174, ptr_175_indices, "", label_150);
		std::vector<Value*> ptr_176_indices;
		ptr_176_indices.push_back(const_int32_zero);
		ptr_176_indices.push_back(int32_172);
		Instruction* ptr_176 = GetElementPtrInst::Create(ptr_175, ptr_176_indices, "", label_150);
		CastInst* ptr_177 = new BitCastInst(ptr_agg_result, Int8PtrTy, "", label_150);
		CastInst* ptr_178 = new BitCastInst(ptr_176, Int8PtrTy, "", label_150);
		std::vector<Value*> void_179_params;
		void_179_params.push_back(ptr_177);
		void_179_params.push_back(ptr_178);
		void_179_params.push_back(const_int32_103);
		void_179_params.push_back(const_int32_one);
		void_179_params.push_back(const_int1_101);
		CallInst* void_179 = CallInst::Create(func_llvm_memcpy_p0i8_p0i8_i32, void_179_params, "", label_150);
		void_179->setCallingConv(CallingConv::C);
		void_179->setTailCall(false);

		ReturnInst::Create(mod->getContext(), label_150);

	}

	// Function: FPU_SET_REG (func_FPU_SET_REG)
	{
		Function::arg_iterator args = func_FPU_SET_REG->arg_begin();
		Value* ptr_state_181 = args++;
		ptr_state_181->setName("state");
		Value* int32_reg_index_182 = args++;
		int32_reg_index_182->setName("reg_index");
		Value* ptr_val = args++;
		ptr_val->setName("val");

		BasicBlock* label_183 = BasicBlock::Create(mod->getContext(), "",func_FPU_SET_REG,0);
		BasicBlock* label_184 = BasicBlock::Create(mod->getContext(), "",func_FPU_SET_REG,0);
		BasicBlock* label_185 = BasicBlock::Create(mod->getContext(), "",func_FPU_SET_REG,0);

		// Block  (label_183)
		AllocaInst* ptr_186 = new AllocaInst(PointerTy_12, "", label_183);
		ptr_186->setAlignment(4);
		AllocaInst* ptr_187 = new AllocaInst(IntegerType::get(mod->getContext(), regWidth), "", label_183);
		ptr_187->setAlignment(4);
		AllocaInst* ptr_rnum_188 = new AllocaInst(IntegerType::get(mod->getContext(), regWidth), "rnum", label_183);
		ptr_rnum_188->setAlignment(4);
		StoreInst* void_189 = new StoreInst(ptr_state_181, ptr_186, false, label_183);
		void_189->setAlignment(4);
		StoreInst* void_190 = new StoreInst(int32_reg_index_182, ptr_187, false, label_183);
		void_190->setAlignment(4);
		LoadInst* ptr_191 = new LoadInst(ptr_186, "", false, label_183);
		ptr_191->setAlignment(4);
		std::vector<Value*> ptr_192_indices;
		ptr_192_indices.push_back(const_int32_zero);
		ptr_192_indices.push_back(const_int32_sixteen);
		Instruction* ptr_192 = GetElementPtrInst::Create(ptr_191, ptr_192_indices, "", label_183);
		std::vector<Value*> ptr_193_indices;
		ptr_193_indices.push_back(const_int32_zero);
		ptr_193_indices.push_back(const_int32_two);
		Instruction* ptr_193 = GetElementPtrInst::Create(ptr_192, ptr_193_indices, "", label_183);
		LoadInst* int32_194 = new LoadInst(ptr_193, "", false, label_183);
		int32_194->setAlignment(1);
		LoadInst* int32_195 = new LoadInst(ptr_187, "", false, label_183);
		int32_195->setAlignment(4);
		BinaryOperator* int32_196 = BinaryOperator::Create(Instruction::Add, int32_194, int32_195, "", label_183);
		StoreInst* void_197 = new StoreInst(int32_196, ptr_rnum_188, false, label_183);
		void_197->setAlignment(4);
		LoadInst* int32_198 = new LoadInst(ptr_187, "", false, label_183);
		int32_198->setAlignment(4);
		ICmpInst* int1_199 = new ICmpInst(*label_183, ICmpInst::ICMP_ULT, int32_198, const_int32_eight, "");
		BranchInst::Create(label_185, label_184, int1_199, label_183);

		// Block  (label_184)
		std::vector<Value*> void_201_params;
		void_201_params.push_back(const_ptr_104);
		void_201_params.push_back(const_ptr_105);
		void_201_params.push_back(const_int32_106);
		CallInst* void_201 = CallInst::Create(func__wassert, void_201_params, "", label_184);
		void_201->setCallingConv(CallingConv::C);
		void_201->setTailCall(false);

		BranchInst::Create(label_185, label_184);

		// Block  (label_185)
		PHINode* int1_203 = PHINode::Create(IntegerType::get(mod->getContext(), 1), 2, "", label_185);
		int1_203->addIncoming(const_int1_100, label_183);
		int1_203->addIncoming(const_int1_101, label_184);

		CastInst* int32_204 = new ZExtInst(int1_203, IntegerType::get(mod->getContext(), 32), "", label_185);
		LoadInst* int32_205 = new LoadInst(ptr_rnum_188, "", false, label_185);
		int32_205->setAlignment(4);
		BinaryOperator* int32_206 = BinaryOperator::Create(Instruction::URem, int32_205, const_int32_eight, "", label_185);
		StoreInst* void_207 = new StoreInst(int32_206, ptr_rnum_188, false, label_185);
		void_207->setAlignment(4);
		LoadInst* int32_208 = new LoadInst(ptr_rnum_188, "", false, label_185);
		int32_208->setAlignment(4);
		LoadInst* ptr_209 = new LoadInst(ptr_186, "", false, label_185);
		ptr_209->setAlignment(4);
		std::vector<Value*> ptr_210_indices;
		ptr_210_indices.push_back(const_int32_zero);
		ptr_210_indices.push_back(const_int32_102);
		Instruction* ptr_210 = GetElementPtrInst::Create(ptr_209, ptr_210_indices, "", label_185);
		std::vector<Value*> ptr_211_indices;
		ptr_211_indices.push_back(const_int32_zero);
		ptr_211_indices.push_back(const_int32_zero);
		Instruction* ptr_211 = GetElementPtrInst::Create(ptr_210, ptr_211_indices, "", label_185);
		std::vector<Value*> ptr_212_indices;
		ptr_212_indices.push_back(const_int32_zero);
		ptr_212_indices.push_back(int32_208);
		Instruction* ptr_212 = GetElementPtrInst::Create(ptr_211, ptr_212_indices, "", label_185);
		CastInst* ptr_213 = new BitCastInst(ptr_212, Int8PtrTy, "", label_185);
		CastInst* ptr_214 = new BitCastInst(ptr_val, Int8PtrTy, "", label_185);
		std::vector<Value*> void_215_params;
		void_215_params.push_back(ptr_213);
		void_215_params.push_back(ptr_214);
		void_215_params.push_back(const_int32_103);
		void_215_params.push_back(const_int32_one);
		void_215_params.push_back(const_int1_101);
		CallInst* void_215 = CallInst::Create(func_llvm_memcpy_p0i8_p0i8_i32, void_215_params, "", label_185);
		void_215->setCallingConv(CallingConv::C);
		void_215->setTailCall(false);

		ReturnInst::Create(mod->getContext(), label_185);

	}

	// Function: NATIVEFPU_TO_LD (func_NATIVEFPU_TO_LD)
	{
		Function::arg_iterator args = func_NATIVEFPU_TO_LD->arg_begin();
		Value* ptr_nf = args++;
		ptr_nf->setName("nf");

		BasicBlock* label_217 = BasicBlock::Create(mod->getContext(), "",func_NATIVEFPU_TO_LD,0);

		// Block  (label_217)
		AllocaInst* ptr_218 = new AllocaInst(PointerTy_10, "", label_217);
		ptr_218->setAlignment(4);
		AllocaInst* ptr_ld = new AllocaInst(Type::getDoubleTy(mod->getContext()), "ld", label_217);
		ptr_ld->setAlignment(8);
		StoreInst* void_219 = new StoreInst(ptr_nf, ptr_218, false, label_217);
		void_219->setAlignment(4);
		InlineAsm* ptr_221 = InlineAsm::get(FuncTy_31, " movl $0, %eax\n fldt (%eax)\n leal $1, %eax\n fstpl (%eax)", "*m,*m,~{eax},~{dirflag},~{fpsr},~{flags}",true); std::vector<Value*> void_220_params;
		void_220_params.push_back(ptr_218);
		void_220_params.push_back(ptr_ld);
		CallInst* void_220 = CallInst::Create(ptr_221, void_220_params, "", label_217);
		void_220->setCallingConv(CallingConv::C);
		void_220->setTailCall(false);
		AttributeSet void_220_PAL;
		void_220_PAL = void_220_PAL.addAttribute(mod->getContext(), ~0U, Attribute::NoUnwind);
		void_220->setAttributes(void_220_PAL);

		LoadInst* double_222 = new LoadInst(ptr_ld, "", false, label_217);
		double_222->setAlignment(8);
		ReturnInst::Create(mod->getContext(), double_222, label_217);

	}

	// Function: LD_TO_NATIVEFPU (func_LD_TO_NATIVEFPU)
	{
		Function::arg_iterator args = func_LD_TO_NATIVEFPU->arg_begin();
		Value* double_ld = args++;
		double_ld->setName("ld");
		Value* ptr_nf_224 = args++;
		ptr_nf_224->setName("nf");

		BasicBlock* label_225 = BasicBlock::Create(mod->getContext(), "",func_LD_TO_NATIVEFPU,0);

		// Block  (label_225)
		AllocaInst* ptr_226 = new AllocaInst(Type::getDoubleTy(mod->getContext()), "", label_225);
		ptr_226->setAlignment(8);
		AllocaInst* ptr_227 = new AllocaInst(PointerTy_10, "", label_225);
		ptr_227->setAlignment(4);
		StoreInst* void_228 = new StoreInst(double_ld, ptr_226, false, label_225);
		void_228->setAlignment(8);
		StoreInst* void_229 = new StoreInst(ptr_nf_224, ptr_227, false, label_225);
		void_229->setAlignment(4);
		InlineAsm* ptr_231 = InlineAsm::get(FuncTy_34, " leal $0, %eax\n fldl (%eax)\n movl $1, %eax\n fstpt (%eax)", "*m,*m,~{eax},~{dirflag},~{fpsr},~{flags}",true); std::vector<Value*> void_230_params;
		void_230_params.push_back(ptr_226);
		void_230_params.push_back(ptr_227);
		CallInst* void_230 = CallInst::Create(ptr_231, void_230_params, "", label_225);
		void_230->setCallingConv(CallingConv::C);
		void_230->setTailCall(false);
		AttributeSet void_230_PAL;
		void_230_PAL = void_230_PAL.addAttribute(mod->getContext(), ~0U, Attribute::NoUnwind);
		void_230->setAttributes(void_230_PAL);

		ReturnInst::Create(mod->getContext(), label_225);

	}

	// Function: callback_adapter_prologue_internal (func_callback_adapter_prologue_internal)
	{
		Function::arg_iterator args = func_callback_adapter_prologue_internal->arg_begin();
		Value* int32_oldEBP = args++;
		int32_oldEBP->setName("oldEBP");
		Value* ptr_pStackPtr = args++;
		ptr_pStackPtr->setName("pStackPtr");
		Value* ptr_pNewStack_241 = args++;
		ptr_pNewStack_241->setName("pNewStack");

		BasicBlock* label_242 = BasicBlock::Create(mod->getContext(), "",func_callback_adapter_prologue_internal,0);

		// Block  (label_242)
		AllocaInst* ptr_243 = new AllocaInst(IntegerType::get(mod->getContext(), regWidth), "", label_242);
		ptr_243->setAlignment(4);
		AllocaInst* ptr_244 = new AllocaInst(Int8PtrTy, "", label_242);
		ptr_244->setAlignment(4);
		AllocaInst* ptr_245 = new AllocaInst(PointerTy_36, "", label_242);
		ptr_245->setAlignment(4);
		AllocaInst* ptr_stackLimit = new AllocaInst(Int8PtrTy, "stackLimit", label_242);
		ptr_stackLimit->setAlignment(4);
		AllocaInst* ptr_pTib = new AllocaInst(getTibPtrTy(mod), "pTib", label_242);
		ptr_pTib->setAlignment(4);
		AllocaInst* ptr_rs = new AllocaInst(PointerTy_12, "rs", label_242);
		ptr_rs->setAlignment(4);
		StoreInst* void_246 = new StoreInst(int32_oldEBP, ptr_243, false, label_242);
		void_246->setAlignment(4);
		StoreInst* void_247 = new StoreInst(ptr_pStackPtr, ptr_244, false, label_242);
		void_247->setAlignment(4);
		StoreInst* void_248 = new StoreInst(ptr_pNewStack_241, ptr_245, false, label_242);
		void_248->setAlignment(4);

		// READ The TIB
		Value* tib_ptr = win32GetTib(label_242);
		StoreInst* void_251 = new StoreInst(tib_ptr, ptr_pTib, false, label_242);
		void_251->setAlignment(4);

		Value* allocBase = win32GetAllocationBase(tib_ptr, label_242);


		// read tib->StackLimit
		LoadInst* ptr_252 = new LoadInst(ptr_pTib, "", false, label_242);
		ptr_252->setAlignment(4);

		Value* ptr_254 = win32GetStackLimit(ptr_252, label_242);

		StoreInst* void_255 = new StoreInst(ptr_254, ptr_stackLimit, false, label_242);
		void_255->setAlignment(4);

		// read tib->StackBase
		LoadInst* ptr_256 = new LoadInst(ptr_pTib, "", false, label_242);
		ptr_256->setAlignment(4);

		Value* stackBase = win32GetStackBase(ptr_256, label_242);

		// stackSize = tib->StackBase - StackLimit
		LoadInst* stackLimit = new LoadInst(ptr_stackLimit, "", false, label_242);
		stackLimit->setAlignment(4);
		CastInst* stackBaseInt = new PtrToIntInst(stackBase, IntegerType::get(mod->getContext(), regWidth), "", label_242);
		CastInst* stackLimitInt = new PtrToIntInst(stackLimit, IntegerType::get(mod->getContext(), regWidth), "", label_242);
		BinaryOperator* commit_size_int = BinaryOperator::Create(Instruction::Sub, stackBaseInt, stackLimitInt, "", label_242);

		BinaryOperator* alloc_size_int =
				BinaryOperator::Create(Instruction::Sub, stackBaseInt, allocBase, "", label_242);

		BinaryOperator* copy_start_offt =
				BinaryOperator::Create(Instruction::Sub, stackLimitInt, allocBase, "", label_242);

		Value* valloc_result = win32CallVirtualAlloc(alloc_size_int, label_242);

		CastInst* valloc_result_i8 = new llvm::IntToPtrInst(valloc_result, Int8PtrTy, "", label_242);

		LoadInst* ptr_266 = new LoadInst(ptr_245, "", false, label_242);
		ptr_266->setAlignment(4);

		// add copy start to new base
		BinaryOperator* copy_dest_int =
				BinaryOperator::Create(Instruction::Add, valloc_result, copy_start_offt, "", label_242);
		CastInst* copy_dest_i8 = new llvm::IntToPtrInst(copy_dest_int, Int8PtrTy, "", label_242);


		StoreInst* void_267 = new StoreInst(valloc_result_i8, ptr_266, false, label_242);
		void_267->setAlignment(4);

		LoadInst* ptr_270 = new LoadInst(ptr_stackLimit, "", false, label_242);
		ptr_270->setAlignment(4);

		std::vector<Value*> memcpy_params;
		memcpy_params.push_back(copy_dest_i8); // dest
		memcpy_params.push_back(ptr_270); // src
		memcpy_params.push_back(commit_size_int); // size
		memcpy_params.push_back(const_int32_one); // align: 1
		memcpy_params.push_back(const_int1_101); // 0 / false

		// call memcpy
		CallInst* void_272 = CallInst::Create(func_llvm_memcpy_p0i8_p0i8_i32, memcpy_params, "", label_242);
		void_272->setCallingConv(CallingConv::C);
		void_272->setTailCall(false);


		// malloc(sizeof(RegState))
		CallInst* ptr_273 = CallInst::Create(func_malloc, const_int32_110, "", label_242);
		ptr_273->setCallingConv(CallingConv::C);
		ptr_273->setTailCall(false);

		CastInst* ptr_274 = new llvm::IntToPtrInst(ptr_273, PointerTy_12, "", label_242);
		StoreInst* void_275 = new StoreInst(ptr_274, ptr_rs, false, label_242);
		void_275->setAlignment(4);
		LoadInst* ptr_279 = new LoadInst(ptr_244, "", false, label_242);
		ptr_279->setAlignment(4);

		LoadInst* ptr_280 = new LoadInst(ptr_stackLimit, "", false, label_242);
		ptr_280->setAlignment(4);
		CastInst* stackPtrInt = new PtrToIntInst(ptr_279, IntegerType::get(mod->getContext(), regWidth), "", label_242);

		// new_esp = (new_stack_base)+(alloc base to start of commit)+(current offset into commit)

		BinaryOperator* esp_off = BinaryOperator::Create(Instruction::Sub, stackPtrInt, stackLimitInt, "", label_242);
		BinaryOperator* add_reserve_size = BinaryOperator::Create(
				Instruction::Add, esp_off, copy_start_offt, "", label_242);

		BinaryOperator* new_esp = BinaryOperator::Create(Instruction::Add, valloc_result, add_reserve_size, "", label_242);

		LoadInst* ptr_285 = new LoadInst(ptr_rs, "", false, label_242);
		ptr_285->setAlignment(4);
		std::vector<Value*> ptr_286_indices;
		ptr_286_indices.push_back(const_int32_zero);
		ptr_286_indices.push_back(const_int32_111);
		Instruction* ptr_286 = GetElementPtrInst::Create(ptr_285, ptr_286_indices, "", label_242);
		StoreInst* void_287 = new StoreInst(new_esp, ptr_286, false, label_242);
		void_287->setAlignment(1);
		LoadInst* int32_288 = new LoadInst(ptr_243, "", false, label_242);
		int32_288->setAlignment(4);
		LoadInst* ptr_289 = new LoadInst(ptr_rs, "", false, label_242);
		ptr_289->setAlignment(4);
		std::vector<Value*> ptr_290_indices;
		ptr_290_indices.push_back(const_int32_zero);
		ptr_290_indices.push_back(const_int32_112);
		Instruction* ptr_290 = GetElementPtrInst::Create(ptr_289, ptr_290_indices, "", label_242);
		StoreInst* void_291 = new StoreInst(int32_288, ptr_290, false, label_242);
		void_291->setAlignment(1);
		LoadInst* ptr_292 = new LoadInst(ptr_rs, "", false, label_242);
		ptr_292->setAlignment(4);
		ReturnInst::Create(mod->getContext(), ptr_292, label_242);


	}


	// Function: callback_adapter_epilogue (func_callback_adapter_epilogue)
	{
		Function::arg_iterator args = func_callback_adapter_epilogue->arg_begin();
		Value* ptr_rs_294 = args++;
		ptr_rs_294->setName("rs");
		Value* ptr_pStack = args++;
		ptr_pStack->setName("pStack");

		BasicBlock* label_295 = BasicBlock::Create(mod->getContext(), "",func_callback_adapter_epilogue,0);

		// Block  (label_295)
		//AllocaInst* ptr_296 = new AllocaInst(PointerTy_12, "", label_295);
		AllocaInst* ptr_296 = new AllocaInst(g_PRegStruct, "", label_295);
		ptr_296->setAlignment(4);
		AllocaInst* ptr_297 = new AllocaInst(Int8PtrTy, "", label_295);
		ptr_297->setAlignment(4);

                AllocaInst* ptr_EAX  = nullptr;
                if( getSystemArch(mod) == _X86_64_) {
                    ptr_EAX = new AllocaInst(IntegerType::get(mod->getContext(), 64), "RAX", label_295);
                } else {
                    ptr_EAX = new AllocaInst(IntegerType::get(mod->getContext(), 32), "EAX", label_295);
                }

		ptr_EAX->setAlignment(4);
		StoreInst* void_298 = new StoreInst(ptr_rs_294, ptr_296, false, label_295);
		void_298->setAlignment(4);
		StoreInst* void_299 = new StoreInst(ptr_pStack, ptr_297, false, label_295);
		void_299->setAlignment(4);
		LoadInst* ptr_300 = new LoadInst(ptr_296, "", false, label_295);
		ptr_300->setAlignment(4);
		std::vector<Value*> ptr_301_indices;
		ptr_301_indices.push_back(const_int32_zero);
		ptr_301_indices.push_back(const_int32_zero);
		Instruction* ptr_301 = GetElementPtrInst::Create(ptr_300, ptr_301_indices, "", label_295);
		LoadInst* int32_302 = new LoadInst(ptr_301, "", false, label_295);
		int32_302->setAlignment(1);
		StoreInst* void_303 = new StoreInst(int32_302, ptr_EAX, false, label_295);
		void_303->setAlignment(4);
		LoadInst* ptr_304 = new LoadInst(ptr_297, "", false, label_295);
		ptr_304->setAlignment(4);

		CastInst* addr_to_free = new PtrToIntInst(ptr_304, Int32Ty, "", label_295);

		Value* int32_305 = win32CallVirtualFree(addr_to_free, label_295);

		LoadInst* ptr_306 = new LoadInst(ptr_296, "", false, label_295);
		ptr_306->setAlignment(4);
		CastInst* ptr_307 = new PtrToIntInst(ptr_306, Int32Ty, "", label_295);
		CallInst* void_308 = CallInst::Create(func_free, ptr_307, "", label_295);
		void_308->setCallingConv(CallingConv::C);
		void_308->setTailCall(false);

		LoadInst* int32_309 = new LoadInst(ptr_EAX, "", false, label_295);
		int32_309->setAlignment(4);
		ReturnInst::Create(mod->getContext(), int32_309, label_295);

	}

	return mod;
}
#endif